# Answer construction
- If we have a question in which we want to find a subset which has a minimum value or the maximum value, then it would be difficult for us. 
	- Eg, consider [this problem](https://leetcode.com/problems/minimum-path-sum/). We only have found out the minimum sum path, but we don't know how to get the actual path for it. 
	- For this given problem, we had defined our state as: `dp[i][j]: minimum path sum to go from i,j - n-1, m-1`
	- In order to get the path, we also need to have another variable, that would define the direction which we took (either down or right) to get the minimum path sum from i,j. 
	- So in this one, we would have to modify our state as `dp[i][j]: {value, choice}`
	- At every step, we would be updating the value and the direction as well
- Basically in every state, we would also now have to store the choice that we made at i, j as well. 
- If we do not do this, we would have to run the entire recursion again and figure out which one fits the problem, because even though we know the final answer this time, we would still have to check all paths and then only we can figure out the one which is needed by us.
- Doing this would just make no sense. Hence by slightly updating our dp state., we have inmproved our tc drastically.
 Sample code for the grid path problem; 
 ```cpp
 vector<vector<pair<int, int>>> dp(n, vector<pair<int, int>>(m, {-1, 0}))
// 0- > took a down direction
// 1 -> took a right direction
int f(int i, int j){ //the function is returning the actual value
	if(i == n || j == m)
		return 1e9 // out of bounds case, return any very big number
	if(i == n-1 && j == m-1)
		return grid[n-1][m-1];
	if(dp[i][j].first != -1)
		return dp[i][j].first // memoization step
	int ans1 = f(i + 1, j), ans2 = f(i, j + 1);
	if(ans1 < ans2)
		dp[i][j].second = 0;
	else
		dp[i][j].second = 1;
	return dp[i][j].first = grid[i][j] + min(ans1, ans2);
}
```
- Now that we have got the path, we just run a normal loop to retrive those values.
- Solve this [one problem](https://codeforces.com/contest/1151/problem/B) now, has a very nice concept of answer generation that has to be used in this

#  Representing Non Integer Parameters in a DP
- untill now, all our dp states were in the form of `dp[i][j] where i and j were integers`
- But what if any one of the parameters was not an interger, or both the parameters were not integers?
	- `dp[int][string]` would not be possible in the way that we have been doing it now?
- We can use a map instead of an array or vector
	- `map<pair<int, string>, value> this would be the key of the map, which would be storing an integer value that correspoonds to the answer of that dp state`

## Unordered map vs ordered map while doing CP
- Unordered Map searches for a key in constant time in avg cases. 
- But in the hacking phase, one can easily construct a test case, which would case the map to give an tle because it would take a linear time to search a key. 
	- [Check out this blog for more on this](https://codeforces.com/blog/entry/62393)
- Hence we would probably consider using a map

## Optimisations while using such non linear dp states: 
- instead of using an dp state like `map<pair<int, string>, value>` we could use something of the form of `map<string, value> dp[n]` 
- We basically have created an array of maps, just to reduce the search time because a map take `O(logn)` to find a key.
- So by making the int values in the array, we have reduced the accessing time to just `log(limit(string))`

